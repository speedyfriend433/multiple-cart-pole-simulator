<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multi-Pole Cart Balancing AI</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        .container {
            width: 800px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        canvas {
            border: 2px solid #333;
            margin: 20px 0;
        }
        .controls {
            margin: 20px 0;
            padding: 10px;
            background: #eee;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        #stats {
            font-family: monospace;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Pole Cart Balancing AI</h1>
        <div class="controls">
            <label>Number of Poles: 
                <select id="poleCount">
                    <option value="1">1 Pole</option>
                    <option value="2">2 Poles</option>
                    <option value="3">3 Poles</option>
                </select>
            </label>
            <button id="startTraining">Start Training</button>
            <button id="stopTraining">Stop Training</button>
            <button id="resetSystem">Reset</button>
        </div>
        <canvas id="cartPoleCanvas" width="800" height="400"></canvas>
        <div id="stats">Training Statistics: Episode: 0 | Reward: 0</div>
    </div>

    <script>
        class MultiPoleSystem {
            constructor(numPoles) {
                this.numPoles = numPoles;
                this.gravity = 9.81;
                this.cartMass = 1.0;
                this.poleMasses = Array(numPoles).fill(0.1);
                this.poleLengths = [0.5, 0.3, 0.2].slice(0, numPoles);
                this.dt = 0.02; // simulation timestep
                this.reset();
            }

            reset() {
                // State: [x, x_dot, θ1, θ1_dot, θ2, θ2_dot, θ3, θ3_dot]
                this.state = new Array(2 + 2 * this.numPoles).fill(0);
                // Add small random perturbations
                this.state = this.state.map(() => (Math.random() - 0.5) * 0.05);
                return this.state.slice();
            }

            step(action) {
                // Simplified physics update
                const [x, x_dot, ...angles] = this.state;
                
                // Update cart position
                const newX = x + this.dt * x_dot;
                const newXDot = x_dot + action * this.dt;

                // Update pole angles (simplified physics)
                const newAngles = [];
                for(let i = 0; i < this.numPoles; i++) {
                    const theta = angles[i*2];
                    const thetaDot = angles[i*2 + 1];
                    
                    // Simplified angular acceleration calculation
                    const thetaAcc = (this.gravity * Math.sin(theta) + 
                                    Math.cos(theta) * (-action - this.poleMasses[i] * 
                                    this.poleLengths[i] * thetaDot * thetaDot * 
                                    Math.sin(theta)) / (this.cartMass + this.poleMasses[i])) / 
                                    (this.poleLengths[i] * (4.0/3.0 - this.poleMasses[i] * 
                                    Math.cos(theta) * Math.cos(theta) / 
                                    (this.cartMass + this.poleMasses[i])));

                    newAngles.push(theta + thetaDot * this.dt);
                    newAngles.push(thetaDot + thetaAcc * this.dt);
                }

                this.state = [newX, newXDot, ...newAngles];
                
                // Calculate reward (negative sum of absolute angles)
                const reward = -Math.abs(newX) - 
                             newAngles.filter((_, i) => i % 2 === 0)
                                     .reduce((sum, angle) => sum + Math.abs(angle), 0);

                // Check if episode is done
                const done = Math.abs(newX) > 2.4 || 
                           newAngles.some((angle, i) => i % 2 === 0 && Math.abs(angle) > 0.7);

                return {
                    state: this.state.slice(),
                    reward: reward,
                    done: done
                };
            }
        }

        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.weights1 = Array(inputSize).fill().map(() => 
                    Array(hiddenSize).fill().map(() => (Math.random() - 0.5) * 2));
                this.weights2 = Array(hiddenSize).fill().map(() => 
                    Array(outputSize).fill().map(() => (Math.random() - 0.5) * 2));
                this.learningRate = 0.001;
            }

            forward(input) {
                // Hidden layer
                this.hidden = input.map((_, i) => 
                    this.weights1[i].reduce((sum, w, j) => sum + w * input[j], 0));
                this.hidden = this.hidden.map(x => Math.tanh(x));

                // Output layer
                const output = this.weights2[0].reduce((sum, w, j) => 
                    sum + w * this.hidden[j], 0);
                
                return Math.tanh(output);
            }

            train(state, action, reward) {
                // Simplified backpropagation
                const output = this.forward(state);
                const error = reward * (action - output);
                
                // Update weights (simplified)
                for(let i = 0; i < this.weights2[0].length; i++) {
                    this.weights2[0][i] += this.learningRate * error * this.hidden[i];
                }
                
                for(let i = 0; i < this.weights1.length; i++) {
                    for(let j = 0; j < this.weights1[i].length; j++) {
                        this.weights1[i][j] += this.learningRate * error * state[i];
                    }
                }
            }
        }

        class CartPoleVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.scale = 200; // pixels per meter
            }

            draw(state, numPoles) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const centerY = this.canvas.height * 0.7;
                const cartWidth = 50;
                const cartHeight = 30;
                
                // Draw cart
                const cartX = this.canvas.width/2 + state[0] * this.scale;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(cartX - cartWidth/2, centerY - cartHeight/2, 
                                cartWidth, cartHeight);

                // Draw poles
                const poleWidth = 6;
                for(let i = 0; i < numPoles; i++) {
                    const angle = state[2 + i*2];
                    const length = [100, 75, 50][i];
                    
                    this.ctx.save();
                    this.ctx.translate(cartX, centerY);
                    this.ctx.rotate(-angle);
                    
                    this.ctx.fillStyle = ['#e74c3c', '#3498db', '#2ecc71'][i];
                    this.ctx.fillRect(-poleWidth/2, -length, poleWidth, length);
                    
                    // Draw joint
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 5, 0, 2*Math.PI);
                    this.ctx.fillStyle = '#000';
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
        }

        // Main application logic
        class CartPoleAI {
            constructor() {
                this.numPoles = 1;
                this.system = new MultiPoleSystem(this.numPoles);
                this.visualizer = new CartPoleVisualizer('cartPoleCanvas');
                this.network = new NeuralNetwork(2 + 2 * this.numPoles, 24, 1);
                this.isTraining = false;
                this.episode = 0;
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('poleCount').addEventListener('change', (e) => {
                    this.numPoles = parseInt(e.target.value);
                    this.reset();
                });

                document.getElementById('startTraining').addEventListener('click', () => {
                    this.isTraining = true;
                    this.train();
                });

                document.getElementById('stopTraining').addEventListener('click', () => {
                    this.isTraining = false;
                });

                document.getElementById('resetSystem').addEventListener('click', () => {
                    this.reset();
                });
            }

            reset() {
                this.system = new MultiPoleSystem(this.numPoles);
                this.network = new NeuralNetwork(2 + 2 * this.numPoles, 24, 1);
                this.episode = 0;
                this.updateStats(0);
            }

            updateStats(reward) {
                document.getElementById('stats').textContent = 
                    `Training Statistics: Episode: ${this.episode} | Reward: ${reward.toFixed(2)}`;
            }

            async train() {
                while(this.isTraining) {
                    let state = this.system.reset();
                    let totalReward = 0;
                    
                    for(let step = 0; step < 500 && this.isTraining; step++) {
                        // Get action from network
                        const action = this.network.forward(state) * 10; // Scale action
                        
                        // Take step in environment
                        const result = this.system.step(action);
                        
                        // Train network
                        this.network.train(state, action/10, result.reward);
                        
                        // Update state and accumulate reward
                        state = result.state;
                        totalReward += result.reward;
                        
                        // Visualize
                        this.visualizer.draw(state, this.numPoles);
                        
                        if(result.done) break;
                        
                        // Add small delay for visualization
                        await new Promise(r => setTimeout(r, 20));
                    }
                    
                    this.episode++;
                    this.updateStats(totalReward);
                }
            }
        }

        // Initialize application
        const app = new CartPoleAI();
    </script>
</body>
</html>
